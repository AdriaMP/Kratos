/*!
* \file   TFEL/Material/Plasticity.hxx
* \brief  this file implements the Plasticity Behaviour.
*         File generated by tfel version 3.3.0-dev
* \author Helfer Thomas
* \date   23 / 11 / 06
 */

#ifndef LIB_TFELMATERIAL_PLASTICITY_HXX
#define LIB_TFELMATERIAL_PLASTICITY_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/LogarithmicStrainComputeAxialStrainIncrementElasticPrediction.hxx"
#include"TFEL/Material/PlasticityBehaviourData.hxx"
#include"TFEL/Material/PlasticityIntegrationData.hxx"

#include"TFEL/Math/General/BaseCast.hxx"

#include "MFront/GenericBehaviour/State.hxx"
#include "MFront/GenericBehaviour/BehaviourData.hxx"
namespace tfel{

namespace material{

struct PlasticityParametersInitializer
{
static PlasticityParametersInitializer&
get();

double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double theta;
double epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

PlasticityParametersInitializer();

PlasticityParametersInitializer(const PlasticityParametersInitializer&);

PlasticityParametersInitializer&
operator=(const PlasticityParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(PlasticityParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis,typename Type,bool use_qt>
class Plasticity;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const Plasticity<hypothesis,Type,false>&);

/*!
* \class Plasticity
* \brief This class implements the Plasticity behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Helfer Thomas
* \date   23 / 11 / 06
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class Plasticity<hypothesis,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>,
public PlasticityBehaviourData<hypothesis,Type,false>,
public PlasticityIntegrationData<hypothesis,Type,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const Plasticity&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef PlasticityBehaviourData<hypothesis,Type,false> BehaviourData;
typedef PlasticityIntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :

typedef typename tfel::math::ComputeBinaryResult<strain,time,tfel::math::OpDiv>::Result DstrainDt;
typedef typename tfel::math::ComputeBinaryResult<DstrainDt,stress,tfel::math::OpDiv>::Result DF_DSEQ_TYPE;



StrainStensor deel;
strain dp;

temperature T_;
stress f;
real df_dseq;
stress df_dp;
StressStensor se;
stress seq;
stress seq_e;
StrainStensor n;
strain p_;
stress lambda;
stress mu;
stress lambda_tdt;
stress mu_tdt;

real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real theta;
real epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
void computeFlow(){
using namespace std;
using namespace tfel::math;
using namespace tfel::material;
using std::vector;
#line 12 "Plasticity.mfront"
this->f       = this->seq-this->H*this->p_-this->s0;
#line 13 "Plasticity.mfront"
this->df_dseq = 1;
#line 14 "Plasticity.mfront"
this->df_dp   = -this->H;
}

bool NewtonIntegration(){
using namespace std;
using namespace tfel::math;
bool converge=false;
bool inversible=true;
strain newton_f;
strain newton_df;
real newton_epsilon = 100*std::numeric_limits<real>::epsilon();
stress mu_3_theta = 3*(Plasticity::theta)*(this->mu);
real surf;
unsigned int iter = 0u;
this->p_=this->p+this->dp;
while((converge==false)&&
(iter<this->iterMax)&&
(inversible==true)){
this->seq = std::max(this->seq_e-mu_3_theta*(this->dp),real(0.f));
this->computeFlow();
surf = (this->f)/(this->young);
if(((surf>newton_epsilon)&&((this->dp)>=0))||((this->dp)>newton_epsilon)){newton_f  = surf;
newton_df = ((this->theta)*(this->df_dp)-mu_3_theta*(this->df_dseq))/(this->young);
} else {
newton_f  =(this->dp);
newton_df = real(1.);
}
if(std::abs(base_cast(newton_df))>newton_epsilon){
this->dp -= newton_f/newton_df;
this->p_  = this->p + (this->theta)*(this->dp);
iter+=1;
converge = (std::abs(tfel::math::base_cast(newton_f))<this->epsilon);
} else {
inversible=false;
}
}

if(inversible==false){
return false;
}

if(iter==this->iterMax){
return false;
}

return true;
}

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->p += this->dp;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief Default constructor (disabled)
Plasticity() =delete ;
//! \brief Copy constructor (disabled)
Plasticity(const Plasticity&) = delete;
//! \brief Assignement operator (disabled)
Plasticity& operator = (const Plasticity&) = delete;

public:

/*!
* \brief Constructor
*/
Plasticity(const PlasticityBehaviourData<hypothesis,Type,false>& src1,
const PlasticityIntegrationData<hypothesis,Type,false>& src2)
: PlasticityBehaviourData<hypothesis,Type,false>(src1),
PlasticityIntegrationData<hypothesis,Type,false>(src2),
deel(typename tfel::math::StensorTraits<StrainStensor>::NumType(0)),
dp(strain(0)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->minimal_time_step_scaling_factor = PlasticityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = PlasticityParametersInitializer::get().maximal_time_step_scaling_factor;
this->theta = PlasticityParametersInitializer::get().theta;
this->epsilon = PlasticityParametersInitializer::get().epsilon;
this->iterMax = PlasticityParametersInitializer::get().iterMax;
this->lambda=tfel::material::computeLambda(this->young,this->nu);
this->mu=tfel::material::computeMu(this->young,this->nu);
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
Plasticity(const mfront::gb::BehaviourData& mgb_d)
: PlasticityBehaviourData<hypothesis,Type,false>(mgb_d),
PlasticityIntegrationData<hypothesis,Type,false>(mgb_d),
deel(typename tfel::math::StensorTraits<StrainStensor>::NumType(0)),
dp(strain(0)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->minimal_time_step_scaling_factor = PlasticityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = PlasticityParametersInitializer::get().maximal_time_step_scaling_factor;
this->theta = PlasticityParametersInitializer::get().theta;
this->epsilon = PlasticityParametersInitializer::get().epsilon;
this->iterMax = PlasticityParametersInitializer::get().iterMax;
this->lambda=tfel::material::computeLambda(this->young,this->nu);
this->mu=tfel::material::computeMu(this->young,this->nu);
this->lambda_tdt = this->lambda;
this->mu_tdt     = this->mu;
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.gradients,this->eto.begin());
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
tfel::fsalgo::copy<StensorSize >::exe(mgb_d.s0.thermodynamic_forces,this->sig.begin());
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->T_ = this->T+(Plasticity::theta)*(this->dT);

this->se=(real{2})*(this->mu)*(tfel::math::deviator(this->eel+(Plasticity::theta)*(this->deto)));
this->seq_e = sigmaeq(this->se);
if(this->seq_e>100*std::numeric_limits<stress>::epsilon()){
this->n = (real{3}/real{2})*(this->se)/(this->seq_e);
} else {
this->n = StrainStensor(strain(0));
}
}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult
computePredictionOperator(const SMFlag smflag, const SMType smt) override{
using namespace std;
if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR){
throw(runtime_error("Plasticity::computePredictionOperator : invalid tangent operator flag"));
}
if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
Dt = (this->lambda_tdt)*Stensor4::IxI()+2*(this->mu_tdt)*Stensor4::Id();
} else {
string msg("Plasticity::computePredictionOperator : ");
msg +="unimplemented feature";
throw(runtime_error(msg));
}

return SUCCESS;
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
* \brief Integrate behaviour law over the time step
*/
IntegrationResult
integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR){
throw(runtime_error("invalid tangent operator flag"));
}
if(!this->NewtonIntegration()){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
this->deel = this->deto-(this->dp)*(this->n);
this->updateStateVariables();
this->sig  = (this->lambda_tdt)*trace(this->eel)*StrainStensor::Id()+2*(this->mu_tdt)*(this->eel);
this->updateAuxiliaryStateVariables();
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using tfel::material::computeElasticStiffness;
using tfel::math::st2tost2;
TFEL_CONSTEXPR real prec = std::numeric_limits<strain>::epsilon()/100;
if(smt==CONSISTENTTANGENTOPERATOR){
computeElasticStiffness<N,Type>::exe(this->Dt,this->lambda_tdt,this->mu_tdt);
if(this->dp>prec){
const real ccto_tmp_1 =  this->dp/this->seq_e;
const auto& M = st2tost2<N,Type>::M();
this->Dt += -4*(this->mu_tdt)*(this->mu)*(this->theta)*(ccto_tmp_1*M-(ccto_tmp_1-this->df_dseq/((this->theta)*(3*(this->mu)*(this->df_dseq)-(this->df_dp))))*((this->n)^(this->n)));
}
} else if((smt==ELASTIC)||(smt==SECANTOPERATOR)){
computeElasticStiffness<N,Type>::exe(this->Dt,this->lambda_tdt,this->mu_tdt);
} else {
return false;
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~Plasticity()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of Plasticity class

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
operator <<(std::ostream& os,const Plasticity<hypothesis,Type,false>& b)
{
using namespace std;
os << "eto : " << b.eto << '\n';
os << "deto : " << b.deto << '\n';
os << "sig : " << b.sig << '\n';
os << "dt : " << b.dt << endl;
os << "T : " << b.T << endl;
os << "dT : " << b.dT << endl;
os << "H : " << b.H << '\n';
os << "s0 : " << b.s0 << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "eel : " << b.eel << '\n';
os << "deel : " << b.deel << '\n';
os << "p : " << b.p << '\n';
os << "dp : " << b.dp << '\n';
os << "T : " << b.T << '\n';
os << "dT : " << b.dT << '\n';
os << "T_ : " << b.T_ << '\n';
os << "se : " << b.se << '\n';
os << "n : " << b.n << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "theta : " << b.theta << '\n';
os << "epsilon : " << b.epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for Plasticity.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MechanicalBehaviourTraits<Plasticity<hypothesis,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 4;
static constexpr unsigned short internal_variables_nb  = 1+StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = true;
static constexpr bool hasPredictionOperator = true;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "Plasticity";
}

};

/*!
* Partial specialisation for Plasticity.
*/
template<typename Type>
class MechanicalBehaviourTraits<Plasticity<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "Plasticity";
}

};

/*!
* Partial specialisation for Plasticity.
*/
template<typename Type>
class MechanicalBehaviourTraits<Plasticity<ModellingHypothesis::PLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "Plasticity";
}

};

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_PLASTICITY_HXX */
